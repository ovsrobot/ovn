AT_BANNER([ovn-controller])

AT_SETUP([ovn-controller - ovn-bridge-mappings])
AT_KEYWORDS([ovn])
ovn_init_db ovn-sb
net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

# Waits until the OVS database contains exactly the specified patch ports.
# Each argument should be of the form BRIDGE PORT PEER.
check_patches () {
    # Generate code to check that the set of patch ports is exactly as
    # specified.
    echo 'ovs-vsctl -f csv -d bare --no-headings --columns=name find Interface type=patch | sort' > query
    for patch
    do
        echo $patch
    done | cut -d' ' -f 2 | sort > expout

    # Generate code to verify that the configuration of each patch
    # port is correct.
    for patch
    do
        set $patch; bridge=$1 port=$2 peer=$3
        echo >>query "ovs-vsctl iface-to-br $port -- get Interface $port type options"
        echo >>expout "$bridge
patch
{peer=$peer}"
    done

    # Run the query until we get the expected result (or until a timeout).
    #
    # (We use sed to drop all "s from output because ovs-vsctl quotes some
    # of the port names but not others.)
    AT_CAPTURE_FILE([query])
    AT_CAPTURE_FILE([expout])
    AT_CAPTURE_FILE([stdout])
    OVS_WAIT_UNTIL([. ./query | sed 's/"//g' > stdout #"
                    diff -u stdout expout >/dev/null])
}

# Make sure that the configured bridge mappings in the Open_vSwitch db
# is mirrored into the Chassis record in the OVN_Southbound db.
check_bridge_mappings () {
    local_mappings=$1
    OVS_WAIT_UNTIL([test x"${local_mappings}" = x$(ovn-sbctl get Chassis ${sandbox} other_config:ovn-bridge-mappings | sed -e 's/\"//g')])
}

# Initially there should be no patch ports.
check_patches

# Configure two ovn-bridge mappings, but no patch ports should be created yet
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0,physnet2:br-eth1])
check_bridge_mappings "physnet1:br-eth0,physnet2:br-eth1"
check_patches

# Create a localnet port, but we should still have no patch ports, as they
# won't be created until there's a localnet port on a logical switch with
# another logical port bound to this chassis.
ovn-sbctl \
    -- --id=@dp101 create Datapath_Binding tunnel_key=101 \
    -- create Port_Binding datapath=@dp101 logical_port=localnet1 tunnel_key=1 \
        type=localnet options:network_name=physnet1
check_patches

# Create a localnet port on a logical switch with a port bound to this chassis.
# Now we should get some patch ports created.
ovn-sbctl \
    -- --id=@dp102 create Datapath_Binding tunnel_key=102 \
    -- create Port_Binding datapath=@dp102 logical_port=localnet2 tunnel_key=1 \
        type=localnet options:network_name=physnet1 \
    -- create Port_Binding datapath=@dp102 logical_port=localvif2 tunnel_key=2
ovs-vsctl add-port br-int localvif2 -- set Interface localvif2 external_ids:iface-id=localvif2
check_patches \
    'br-int  patch-br-int-to-localnet2 patch-localnet2-to-br-int' \
    'br-eth0 patch-localnet2-to-br-int patch-br-int-to-localnet2'

# Add logical patch ports to connect new logical datapath.
#
# OVN no longer uses OVS patch ports to implement logical patch ports, so
# the set of OVS patch ports doesn't change.
AT_CHECK([ovn-sbctl \
    -- --id=@dp1 create Datapath_Binding tunnel_key=1 \
    -- --id=@dp2 create Datapath_Binding tunnel_key=2 \
    -- create Port_Binding datapath=@dp1 logical_port=foo tunnel_key=1 type=patch options:peer=bar \
    -- create Port_Binding datapath=@dp2 logical_port=bar tunnel_key=2 type=patch options:peer=foo \
    -- create Port_Binding datapath=@dp1 logical_port=dp1vif tunnel_key=3 \
| uuidfilt], [0], [<0>
<1>
<2>
<3>
<4>
])
ovs-vsctl add-port br-int dp1vif -- set Interface dp1vif external_ids:iface-id=dp1vif
check_patches \
    'br-int  patch-br-int-to-localnet2 patch-localnet2-to-br-int' \
    'br-eth0 patch-localnet2-to-br-int patch-br-int-to-localnet2'

# Delete the mapping and the ovn-bridge-mapping patch ports should go away.
AT_CHECK([ovs-vsctl remove Open_vSwitch . external-ids ovn-bridge-mappings])
check_bridge_mappings
check_patches

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP

# Checks that ovn-controller populates datapath-type and iface-types
# correctly in the Chassis other_config column.
AT_SETUP([ovn-controller - Chassis other_config])
AT_KEYWORDS([ovn])
ovn_init_db ovn-sb

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

sysid=${sandbox}

# Make sure that the datapath_type set in the Bridge table
# is mirrored into the Chassis record in the OVN_Southbound db.
check_datapath_type () {
    datapath_type=$1
    chassis_datapath_type=$(ovn-sbctl get Chassis ${sandbox} other_config:datapath-type | sed -e 's/"//g') #"
    test "${datapath_type}" = "${chassis_datapath_type}"
}

OVS_WAIT_UNTIL([check_datapath_type ""])

ovs-vsctl set Bridge br-int datapath-type=foo
OVS_WAIT_UNTIL([check_datapath_type foo])

# Change "ovn-bridge-mappings" value. It should not change the "datapath-type".
ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-mappings=foo-mapping
check_datapath_type foo

ovs-vsctl set Bridge br-int datapath-type=bar
OVS_WAIT_UNTIL([check_datapath_type bar])

ovs-vsctl set Bridge br-int datapath-type=\"\"
OVS_WAIT_UNTIL([check_datapath_type ""])

# Set the datapath_type in external_ids:ovn-bridge-datapath-type.
ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-datapath-type=foo
OVS_WAIT_UNTIL([check_datapath_type foo])

# Change the br-int's datapath type to bar.
# It should be reset to foo since ovn-bridge-datapath-type is configured.
ovs-vsctl set Bridge br-int datapath-type=bar
OVS_WAIT_UNTIL([test foo=`ovs-vsctl get Bridge br-int datapath-type`])
OVS_WAIT_UNTIL([check_datapath_type foo])

ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-datapath-type=foobar
OVS_WAIT_UNTIL([test foobar=`ovs-vsctl get Bridge br-int datapath-type`])
OVS_WAIT_UNTIL([check_datapath_type foobar])

expected_iface_types=$(ovs-vsctl get Open_vSwitch . iface_types | tr -d '[[]] ""')
echo "expected_iface_types = ${expected_iface_types}"
chassis_iface_types=$(ovn-sbctl get Chassis ${sysid} other_config:iface-types | sed -e 's/\"//g')
echo "chassis_iface_types = ${chassis_iface_types}"
AT_CHECK([test "${expected_iface_types}" = "${chassis_iface_types}"])

# Change the value of other_config:iface-types using ovn-sbctl.
# ovn-controller should again set it back to proper one.
ovn-sbctl set Chassis ${sysid} other_config:iface-types="foo"
OVS_WAIT_UNTIL([
    chassis_iface_types=$(ovn-sbctl get Chassis ${sysid} other_config:iface-types | sed -e 's/\"//g')
    echo "chassis_iface_types = ${chassis_iface_types}"
    test "${expected_iface_types}" = "${chassis_iface_types}"
])

# Set the value of external_ids:system-id and make sure it's mirrored
# in the Chassis record in the OVN_Southbound database.
sysid=${sysid}-foo
ovs-vsctl set Open_vSwitch . external-ids:system-id="${sysid}"
OVS_WAIT_UNTIL([
    chassis_id=$(ovn-sbctl get Chassis "${sysid}" name)
    test "${sysid}" = "${chassis_id}"
])
OVS_WAIT_UNTIL([
    chassis_id=$(ovn-sbctl get Chassis_Private "${sysid}" name)
    test "${sysid}" = "${chassis_id}"
])

# Only one Chassis_Private record should exist.
OVS_WAIT_UNTIL([
    test $(ovn-sbctl --columns _uuid list chassis_private | wc -l) -eq 1
])

# Simulate system-id changing while ovn-controller is disconnected from the
# SB.
valid_remote=$(ovs-vsctl get Open_vSwitch . external_ids:ovn-remote)
invalid_remote=tcp:0.0.0.0:4242
ovs-vsctl set Open_vSwitch . external_ids:ovn-remote=${invalid_remote}
expected_state="not connected"
OVS_WAIT_UNTIL([
    test "${expected_state}" = "$(ovn-appctl -t ovn-controller connection-status)"
])
sysid=${sysid}-bar
ovs-vsctl set Open_vSwitch . external-ids:system-id="${sysid}"
ovs-vsctl set Open_vSwitch . external_ids:ovn-remote=${valid_remote}
OVS_WAIT_UNTIL([
    chassis_id=$(ovn-sbctl get Chassis "${sysid}" name)
    test "${sysid}" = "${chassis_id}"
])
OVS_WAIT_UNTIL([
    chassis_id=$(ovn-sbctl get Chassis_Private "${sysid}" name)
    test "${sysid}" = "${chassis_id}"
])

# Only one Chassis_Private record should exist.
OVS_WAIT_UNTIL([
    test $(ovn-sbctl --columns _uuid list chassis_private | wc -l) -eq 1
])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP

# Checks that ovn-controller correctly maintains the mapping from the Encap
# table in the Southbound database to OVS in the face of changes on both sides
AT_SETUP([ovn-controller - change Encap properties])
AT_KEYWORDS([ovn])
ovn_init_db ovn-sb

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

check_tunnel_property () {
    test "`ovs-vsctl get interface ovn-fakech-0 $1`" = "$2"
}

# Start off with a remote chassis supporting STT
ovn-sbctl chassis-add fakechassis stt 192.168.0.2
OVS_WAIT_UNTIL([check_tunnel_property type stt])

# See if we switch to Geneve as the first choice when it is available
# With multi-VTEP support we support tunnels with different IPs to the
# same chassis, and hence use the IP to annotate the tunnel (along with
# the chassis-id in ovn-chassis-id); if we supply a different IP here
# we won't be able to co-relate this to the tunnel port that was created
# in the previous step and, as a result, will end up creating another tunnel,
# ie. we can't just lookup using "ovn-fakech-0". So, need to use the same IP
# as above, i.e 192.168.0.2, here.
encap_uuid=$(ovn-sbctl add chassis fakechassis encaps @encap -- --id=@encap create encap type=geneve ip="192.168.0.2")
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# Check that changes within an encap row are propagated
ovn-sbctl set encap ${encap_uuid} ip=192.168.0.2
OVS_WAIT_UNTIL([check_tunnel_property options:remote_ip "\"192.168.0.2\""])

# Change the type on the OVS side and check than OVN fixes it
ovs-vsctl set interface ovn-fakech-0 type=vxlan
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# Delete the port entirely and it should be resurrected
ovs-vsctl del-port ovn-fakech-0
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP

# Check ovn-controller connection status to Southbound database
AT_SETUP([ovn-controller - check sbdb connection])
AT_KEYWORDS([ovn])
ovn_init_db ovn-sb

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

check_sbdb_connection () {
    test "$(ovs-appctl -t ovn-controller connection-status)" = "$1"
}

OVS_WAIT_UNTIL([check_sbdb_connection connected])

ovs-vsctl set open . external_ids:ovn-remote=tcp:192.168.0.10:6642
OVS_WAIT_UNTIL([check_sbdb_connection 'not connected'])

# reset the remote for clean-up
ovs-vsctl set open . external_ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock
# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP

# Checks that ovn-controller recreates its chassis record when deleted externally.
AT_SETUP([ovn-controller - Chassis self record])
AT_KEYWORDS([ovn])
ovn_init_db ovn-sb

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])
# Delete the chassis "hv"
ovn-sbctl chassis-del hv
# ovn-controller should recreate its chassis row.
OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP

# Checks that ovn-controller increments the nb_cfg value in the Chassis_Private table
AT_SETUP([ovn-controller - Bump Chassis_Private nb_cfg value])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

# Bump the NB_Global nb_cfg value
nb_global_id=$(ovn-nbctl --columns _uuid --bare find nb_global)
ovn-nbctl set NB_Global ${nb_global_id} nb_cfg=999

# ovn-controller should bump the nb_cfg in the chassis_private table
OVS_WAIT_UNTIL([test x999 = x`ovn-sbctl --columns nb_cfg --bare find chassis_private`])

# Assert that the the nb_cfg from the Chassis table was not incremented
OVS_WAIT_UNTIL([test x0 = x`ovn-sbctl --columns nb_cfg --bare find chassis`])

OVN_CLEANUP([hv])
AT_CLEANUP

# Test unix command: debug/delay-nb-cfg-report
AT_SETUP([ovn-controller - debug/delay-nb-cfg-report])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

AT_CHECK([ovn-appctl -t ovn-controller debug/delay-nb-cfg-report 2], [0],
         [delay nb_cfg report for 2 seconds.
])

AT_FAIL_IF([ovn-nbctl --timeout=1 --wait=hv sync])

# sleep another 1 sec so that the original 2 sec sleep is done in ovn-controller
sleep 1

AT_CHECK([ovn-nbctl --timeout=3 --wait=hv sync])

AT_CHECK([ovn-appctl -t ovn-controller debug/delay-nb-cfg-report 0], [0],
         [no delay for nb_cfg report.
])

AT_CHECK([ovn-nbctl --timeout=1 --wait=hv sync])

OVN_CLEANUP([hv])
AT_CLEANUP
